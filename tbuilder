#!/usr/bin/env python3

import argparse
import glob
import os
import pathlib
import re
import shutil
import subprocess
import sys
import yaml # pip PyYAML
import xml.etree.ElementTree as ET

# commands abstraction
class Commands:
    def __init__(self):
        # check createrepo is with _c suffix
        if shutil.which("createrepo_c") is not None:
            self._createrepo = "createrepo_c"
        elif shutil.which("createrepo") is not None:
            self._createrepo = 'createrepo'
        else:
            print("Cannot find createrepo")
            sys.exit(-1)

        # check whether to use sfdk or not
        if shutil.which("mb2") is not None and shutil.which("sb2") is not None:
            self.use_sfdk = False
        elif shutil.which("sfdk") is not None:
            self.use_sfdk = True
        else:
            print('Cannot find sfdk nor sb2/mb2')
            sys.exit(-1)

    def createrepo(self, rpmpath):
        return commands._createrepo + ' ' + rpmpath

    def makesection(self, tool, bdir, rpmpath, specpath, project_name,
                    buildoptions, srcpath, rpmbuild):
        make = ''
        if self.use_sfdk:
            make += '\t' + 'sfdk config no-fix-version\n'
            make += '\t' + 'sfdk config target=' + tool + '\n'
            make += '\t' + 'sfdk config output-dir=' + rpmpath + '\n'
            make += '\t' + 'sfdk config snapshot=%s \n' % project_name
            make += '\t' + '(cd %s && ' % bdir
            make += 'sfdk config specfile=' + specpath + ' && '
            make += 'sfdk build -d %s %s %s)\n' % (buildoptions, srcpath, rpmbuild)
        else:
            make += '\t' + \
                '(cd {bdir} && mb2 -t {target} -o {output} -s {spec} --snapshot={snap} build -d {bopts} {src} {rpmbuild})\n'.format(
                    bdir = bdir, target = tool, output = rpmpath, spec = specpath,
                    snap = project_name, bopts = buildoptions, src = srcpath, rpmbuild = rpmbuild)

        return make


    def refreshsystem(self, tool):
        if self.use_sfdk:
            return "sfdk tools exec %s zypper refresh" % tool
        return "sb2 -t %s -R zypper refresh" % tool

    def systemhas(self, tool):
        if self.use_sfdk:
            # prepare sfdk to run
            run_with_check("sfdk config target=" + tool)
            run_with_check("sfdk config no-snapshot")
            cmd = "sfdk build-shell zypper -x search --provides --match-exact".split()
        else:
            cmd = "sb2 -t %s zypper -x search --provides --match-exact" % tool
            cmd = cmd.split()
        return cmd


# global commands instance
commands = Commands()

# helper functions
def run_with_check(cmd, check_error=True, cwd = None):
    if isinstance(cmd, str):
        cmd = cmd.split()
    proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd)
    if proc.returncode and check_error:
        print('Error while executing', cmd)
        print('Return code:', proc.returncode)
        print('STDOUT:\n' + proc.stdout.decode('utf-8'))
        print('STDERR:\n' + proc.stderr.decode('utf-8'))
        sys.exit(-2)

    return proc.stdout.decode('utf-8'), proc.stderr.decode('utf-8')

def query(exe, specname, q, macros = [], check_error=True, cwd = None):
    cmd = [exe, '-q', q]
    for m in macros:
        cmd.append('--define=%s' % m)
    cmd.append(specname)
    stdout, stderr = run_with_check(cmd, check_error, cwd = cwd)

    # stdout = proc.stdout.decode('utf-8')
    result = []
    result_full = {}
    for l in stdout.split('\n'):
        r = l.split()
        if len(r) > 0:
            rr = r[0].strip()
            result.append(rr)
            result_full[l.strip()] = rr
    return result, result_full

def qname(specname, macros = [], cwd = None):
    return query('rpmspec', specname, '--queryformat=%{NAME} ', macros, cwd = cwd)[0][0]

def qbuildrequires(specname, macros = [], cwd = None):
    q, qf = query('rpmspec', specname, '--buildrequires', macros, cwd = cwd)
    return set(q), qf

def qprovides(specname, macros = [], cwd = None):
    return set(query('rpmspec', specname, '--provides', macros, cwd = cwd)[0])

def qname(specname, macros = [], cwd = None):
    return query('rpmspec', specname, '--queryformat=%{NAME} ', macros, cwd = cwd)[0][0]

def qbinprovides(rpmname, macros = []):
    return set(query('rpm', rpmname, '--provides', macros, check_error=False)[0])

def qbinsrcname(rpmname, macros = []):
    s = query('rpm', rpmname, '--queryformat=%{SOURCERPM} ', macros, check_error=False)[0][0]
    return s.rsplit('-', 2)[0]

def qsystemhas(r, tool):
    cmd = commands.systemhas(tool)
    cmd.append(r)
    proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    # zypper returns non-zero if failing to find
    if proc.returncode:
        return False # assume that it just failed to find
    s = proc.stdout.decode('utf-8')
    root = ET.fromstring(s)
    for i in root.iter('solvable'):
        return True
    return False

def refreshsystem(tool):
    print('Refreshing zypper cache for', tool)
    cmd = commands.refreshsystem(tool)
    s, e = run_with_check(cmd)
    print(s)

# definition of dirs
def rpmdir(root, tool):
    return os.path.join(root, tool)

def builddir(tool):
    return os.path.join('build', tool)

def targetdir(tool):
    return os.path.join(builddir(tool), 'target')

# processing of targets
def tf(s):
    # replace chars that may cause issues for make or filesystem
    return re.sub('[():%]', '_', s)

def target_dir(name):
    return tf(os.path.join(name, '.directory'))

def target_builddir(tool):
    return tf(target_dir(builddir(tool)))

def target_targetdir(tool):
    return tf(target_dir(targetdir(tool)))

def target_rpmdir(root, tool):
    return tf(target_dir(rpmdir(root, tool)))

def target_generic(name, tool):
    return tf(os.path.join(targetdir(tool), name))

def target_spec(s, tool):
    return tf(target_generic(os.path.basename(s), tool))

def target_provides(p, tool):
    p = p.replace('/', '_')
    return tf(target_generic(p, tool))

# add targets that are provided already
def add_rpm_targets(rpmfname, prov):
    stat = os.stat(rpmfname)
    for p in prov:
        tname = target_provides(p, tool)
        if not os.path.exists(tname):
            f = open(tname, "w")
            f.write(rpmfname)
            f.close()
            del f
        else:
            # modify timestamp only if target_provides is older than RPM.
            # this is to avoid touching timestamps as much as possible.
            # otherwise, have seen some rebuilds triggered by incorrect
            # timestamps
            sp = os.stat(tname)
            if sp.st_mtime_ns < stat.st_mtime_ns:
                os.utime(tname, ns=(stat.st_atime_ns, stat.st_mtime_ns))

# make snippets
def make_dir(dname):
    return \
        target_dir(dname) + ':\n' + \
        '\tmkdir -p ' + dname + '\n' + \
        '\ttouch ' + target_dir(dname) + '\n' + \
        '\n'


class Spec:
    def __init__(self, s, macros):
        self.specfname = s
        # determine src and spec abs path
        ## handle case where we can have relative symbolic links
        ## as well as rpm within the source dir which is symlink.
        ## for these cases, resolve symlink late
        slink = os.readlink(s)
        rpmdir, specfname_rel = os.path.split(slink)
        self.srcpath, rpmpath_rel = os.path.split(rpmdir)
        self.specfname_rel = os.path.join(rpmpath_rel, specfname_rel)
        # handle relative path
        if not os.path.isabs(self.srcpath):
            self.srcpath = os.path.abspath( os.path.join(os.path.dirname(s), self.srcpath) )
        # fill data using queries
        self.name = qname(self.specfname_rel, macros, cwd = self.srcpath)
        self.requires, self.requires_full = qbuildrequires(self.specfname_rel, macros, cwd = self.srcpath)
        self.provides = set()
        self.missing = set()

    def __str__(self):
        return "{name}: {specfname}  / requires: {requires} / provides: {provides} / missing: {missing}".format(**self.__dict__)

    def make_provides(self, tool):
        make = ''
        s = target_spec(self.specfname, tool)
        for p in self.provides:
            t = target_provides(p, tool)
            make += "%s: %s %s\n\ttouch '%s'\n\n" % (t, target_targetdir(tool), s, t)
        return make

    def make_spec(self, system_provided, tool, project_name, rpmroot, buildoptions, macros, insource):
        req = self.requires - system_provided
        make = target_spec(self.specfname, tool) + \
            ': %s %s %s %s ' % (target_targetdir(tool), target_builddir(tool),
                                target_rpmdir(rpmroot, tool),
                                self.specfname)
        make += ' '.join([target_provides(i, tool) for i in req])
        make += '\n'
        # determine src and spec path
        sbase = os.path.basename(self.specfname)
        bdir = os.path.join(builddir(tool), sbase)
        specpath = os.path.abspath(self.specfname)
        rpmpath = os.path.abspath(rpmdir(rpmroot, tool))
        # build options for rpmbuild
        if len(macros) > 0:
            rpmbuild = " " + " ".join(['--define="%s"' % m for m in macros])
        else:
            rpmbuild = ""
        # write build section
        make += '\t' + '@echo\n'
        make += '\t' + '@echo Building %s for %s\n' % (self.specfname, tool)
        make += '\t' + '@echo\n'
        if not insource:
            make += '\t' + 'rm -rf %s\n' % bdir
        make += '\t' + 'mkdir -p %s\n' % bdir
        if insource:
            make += '\t' + 'rsync -a --delete %s/ %s/\n' % (self.srcpath, bdir)
            srcpath = "."
            specpath = self.specfname_rel
            buildoptions = buildoptions + " -p"
        else:
            srcpath = self.srcpath

        make += commands.makesection(bdir = bdir, tool = tool, rpmpath = rpmpath, specpath = specpath,
                                     project_name = project_name, buildoptions = buildoptions,
                                     srcpath = srcpath, rpmbuild = rpmbuild)

        # finalize
        make += '\t' + commands.createrepo(rpmpath) + '\n'
        make += '\ttouch ' + target_spec(self.specfname, tool) + '\n'
        make += '\n'
        return make


class TargetDirTracker:
    def __init__(self, tool):
        self.targets = dict()
        self.tool = tool
        self.update()

    def update(self):
        # return True if some targets got updated
        tgts = dict()
        for f in glob.glob(os.path.join(targetdir(self.tool), "*")):
            stat = os.stat(f)
            tgts[f] = stat.st_mtime_ns
        if tgts == self.targets:
            return False
        self.targets = tgts
        return True


##########################################################
## main

parser = argparse.ArgumentParser(description='Generate project build files')

parser.add_argument('project_directory', help='Directory containing project files')

args = parser.parse_args()

project = args.project_directory
if not os.path.isdir(project):
    print('Project directory does not exist or is not a directory:', project)
    sys.exit(-1)

# change to project dir
os.chdir(project)

# load config
with open("config.yaml", "r") as f:
    config = yaml.safe_load(f)

project_name = config.get('project', '')
targets = config.get('targets', [])
rpms = config.get('rpms', '')
macros = config.get('macros', [])
buildoptions = config.get('buildoptions', '')
provides_extra = config.get('provides', dict())
insource = config.get('insource', [])
specdir = "spec"
cachefname = "cache.yaml"

# add subdir to required keys
provides_extra = { os.path.join(specdir, k): v for k,v in provides_extra.items() }
if 'ALL' in insource:
    insource = ['ALL']
else:
    insource = [ os.path.join(specdir, k) for k in insource ]

# check for required parameters
if len(project_name) < 1:
    print('No project name specified in the project config.yaml')
    sys.exit(-1)
if len(targets) < 1:
    print('No targets specified in the project config.yaml')
    sys.exit(-1)
if len(rpms) < 1:
    print('No RPMS directory specified in the project config.yaml')
    sys.exit(-1)


# main loop
summary = {}
for tool in targets:
    print('Starting builds for', tool, '\n')

    # initialize for each target

    refreshsystem(tool)

    # load RPMs and their properties
    specs = {}
    for f in glob.glob(os.path.join(specdir,"*.spec")):
        s = Spec(f, macros)
        specs[ s.name ] = s

    print('Loaded SPECs:\n')
    for _, s in specs.items():
        print(s.specfname, ':', s.name)
    print()

    system_provided = set()
    system_missing = set()
    targets_state = TargetDirTracker(tool)

    # prepare directories
    rdir = rpmdir(rpms, tool)
    bdir = builddir(tool)
    os.makedirs(rdir, exist_ok = True)
    os.makedirs(bdir, exist_ok = True)
    os.makedirs(targetdir(tool), exist_ok = True)

    # load cache if it is available
    current_cache = os.path.join(bdir, cachefname)
    if os.path.exists(current_cache):
        with open(current_cache, 'r') as f:
            c = yaml.safe_load(f)
            if isinstance(c, dict):
                system_provided = set(c.get('system_provided', []))
                system_missing = set(c.get('system_missing', []))

    # start build loop
    Done = False
    while not Done:

        # query provided symbols in current ready RPMs
        local_provided = set()
        for rpmfname in glob.glob(os.path.join(rdir, "*.rpm")):
            srcname = qbinsrcname(rpmfname)
            prov = qbinprovides(rpmfname)
            add_rpm_targets(rpmfname, prov)
            local_provided.update(prov)
            if srcname in specs:
                specs[srcname].provides.update(prov)

        if len(local_provided) > 0:
            print('Available local provided symbols:', " ".join(local_provided), "\n")

        # determine whether packages are missing something preventing the build
        checked_in_system = False
        for _, s in specs.items():
            s.missing = set()
            for r, rsimple in s.requires_full.items():
                if r in system_provided or rsimple in local_provided:
                    continue
                elif r in system_missing:
                    s.missing.add(r)
                else:
                    checked_in_system = True
                    print('Check for availibility in the system:', r, flush=True, end=' : ')
                    in_system = qsystemhas(r, tool)

                    if in_system:
                        print('Available')
                        system_provided.add(r)
                        system_provided.add(rsimple)
                        continue
                    else:
                        print('Requires building')
                        system_missing.add(r)
                        s.missing.add(r)

        if checked_in_system: print()

        # update cache
        with open(current_cache, 'w') as f:
            c = dict(system_provided = list(system_provided),
                     system_missing = list(system_missing))
            yaml.safe_dump(c, f)

        # summarize findings
        tomake = set()
        skipped = set()
        for k, s in specs.items():
            if len(s.missing) > 0:
                print('{name}({spec}) has missing dependencies:'.format(name = s.name,
                                                                        spec = s.specfname),
                      " ".join(s.missing))
                skipped.add(k)
            else:
                tomake.add(k)
        print()

        print('Packages included into the current build:', " ".join(tomake))

        # generate Makefile
        main_deps = ""

        make = "# This is generated Makefile and can be overwritten by a script\n\n"
        make += 'all: all_packages\n\n'

        main_deps += " ".join([ target_spec(specs[s].specfname, tool) for s in tomake ]) + " "

        # create directories
        make += make_dir(builddir(tool))
        make += make_dir(targetdir(tool))
        make += make_dir(rpmdir(rpms, tool))

        for k, s in specs.items():
            # skip packages that we cannot build yet
            if k not in tomake:
                continue

            # provides targets
            make += s.make_provides(tool)

            make += s.make_spec(system_provided = system_provided,
                                tool = tool,
                                project_name = project_name, rpmroot = rpms,
                                buildoptions = buildoptions, macros = macros,
                                insource = (s.specfname in insource or 'ALL' in insource))

        make += 'all_packages: %s\n\t@echo\n\t@echo All done\n\t@echo\n\n' % main_deps

        # disable parallel execution
        make += '.NOTPARALLEL:\n\n'

        # write Makefile
        makefname = os.path.join(bdir, "Makefile")
        with open(makefname, "w") as f:
            f.write(make)

        # start make in the background
        logfname = os.path.join(bdir, "build.log")
        print('Starting build with the log available at', logfname)
        with open(logfname, "w") as flog:
            po = subprocess.Popen(["make", "-f", makefname],
                                  bufsize = 0,
                                  stdout=flog, stderr=subprocess.STDOUT)
            result = po.wait()
            if result != 0:
                print('Error while running Make. See log for details')
                summary[tool] = 'Error while running Make. See {log} for details'.format(log = logfname)
                break
            else:
                print('Build successful\n')

        # current summary for this toolkit
        summary[tool] = "Build packages: " + " ".join(tomake) + "\nSkipped packages: " + " ".join(skipped)

        # update conditions
        changed = targets_state.update()
        if not changed:
            print('Nothing new, stopping for target', tool, '\n')
            Done = True
        else:
            print('Targets changed or updated, continue building\n')


print('\nAll builds finished\n')

for t, s in summary.items():
    print(t,':')
    print(s, '\n\n')
